:toc:
= Architecture Linting Report

[[default]]
[role=group,includesGroups=,includesGroups="structure:Default"]


== Default Rules

This section describes that default rules that are executed during each build.

- <<structure:Default>>

[[structure:Default]]
[role=group,includesConcepts="arch:markAdapterLayer,arch:markServiceLayer,arch:markDomainLayer,arch:markDomains,arch:markServices,arch:markAdapters",includesConstraints="arch:detectIllegalLayerDependencies,arch:detectIllegalDomainDependencies,arch:detectIllegalAdapterDependencies"]
== Structure

[[arch:markAdapterLayer]]
[source,cypher,role=concept]
.Label the layer for the adapters with the label `Adapters`, `ToplevelLayer` and `HexArch`
----
MATCH (package:Java:Package)
WHERE package.fqn =~ 'corp\\.fantastic\\.[a-z][a-z0-9]*\\.adapters'
SET package:Adapters:HexArch:ToplevelLayer
RETURN package
----

[[arch:markAdapters]]
[source,cypher,role=concept,requiresConcepts="arch:markAdapterLayer"]
.Labels each single adapter with the label `Adapter` and `HexArch`
----
MATCH (adapterLayer:Adapters:HexArch)-[:CONTAINS]->(adapter:Package:Java)
WHERE adapter.name <> "common"
SET adapter:HexArch:Adapter
return adapter
----


[[arch:markServiceLayer]]
[source,cypher,role=concept]
.Label  the layer for the services with the label `Services`, `ToplevelLayer` and `HexArch`
----
MATCH (package:Java:Package)
WHERE package.fqn =~ 'corp\\.fantastic\\.[a-z][a-z0-9]*\\.services'
SET package:Services:HexArch:ToplevelLayer
RETURN package
----

[[arch:markServices]]
[source,cypher,role=concept,requiresConcepts="arch:markServiceLayer"]
.Labels each single service with the label `Service` and `HexArch`
----
MATCH (serviceLayer:Services:HexArch)-[:CONTAINS]->(service:Package:Java)
WHERE service.name <> "common"
SET service:HexArch:Service
return service
----

[[arch:markDomainLayer]]
[source,cypher,role=concept]
.Label the layer for the adapters with the label `Domains`, `ToplevelLayer` and `HexArch`
----
MATCH (package:Java:Package)
WHERE package.fqn =~ 'corp\\.fantastic\\.[a-z][a-z0-9]*\\.domains'
SET package:Domains:HexArch:ToplevelLayer
RETURN package
----

[[arch:markDomains]]
[source,cypher,role=concept,requiresConcepts="arch:markDomainLayer"]
.Labels each single domain with the label `Domain` and `HexArch`
----
MATCH (domainLayer:Domains:HexArch)-[:CONTAINS]->(domain:Package:Java)
WHERE domain.name <> "common"
SET domain:HexArch:Domain
return domain
----


[[arch:markAllowedDependencies]]
[source,cypher,role=concept,requiresConcepts="arch:markDomainLayer,arch:markAdapterLayer,arch:markServiceLayer"]
.Label the allowed relationships between the layers
----
MATCH
  (adapterLayer:HexArch:Adapters),
  (domainLayer:HexArch:Domains),
  (serviceLayer:HexArch:Services)
MERGE
  (adapterLayer)-[:IS_ALLOWED_TO_USE]->(serviceLayer)
MERGE
  (serviceLayer)-[:IS_ALLOWED_TO_USE]->(domainLayer)
MERGE
  (domainLayer)-[:IS_ALLOWED_TO_USE]->(adapterLayer)
RETURN
  count(*) as Count
----

[[arch:markExistingRelations]]
[source,cypher,role=concept,requiresConcepts="arch:markDomainLayer,arch:markAdapterLayer,arch:markServiceLayer"]
.Label the real existing usage relationships
----
MATCH
  (l1:HexArch:ToplevelLayer)-[:CONTAINS*]->(t1:Type),
  (l2:HexArch:ToplevelLayer)-[:CONTAINS*]->(t2:Type),
  (t1)-[:DEPENDS_ON]->(t2)
WHERE
  l1 <> l2 AND t1 <> t2
WITH
  l1, l2, count(*) as weight
MERGE
  (l1)-[d:DEPENDS_ON_LAYER]->(l2)
SET
  d.weight = weight
RETURN
  l1 as Layer, l2 as LayerDependency, d as DependencyWeight
----

[[arch:detectIllegalLayerDependencies]]
[source,cypher,role=constraint,requiresConcepts="arch:markAllowedDependencies,arch:markExistingRelations"]
.Find all not allowed dependencies between the layers of the hexagonal architecture
----
MATCH
  (l1:ToplevelLayer)-[:DEPENDS_ON_LAYER]->(l2:ToplevelLayer)
WHERE NOT
  (l1:ToplevelLayer)-[:IS_ALLOWED_TO_USE]->(l2:ToplevelLayer)
WITH
  l1, l2
MATCH
  (l1)-[:CONTAINS*]->(t1:Type),
  (l2)-[:CONTAINS*]->(t2:Type),
  (t1)-[:DEPENDS_ON]->(t2)
RETURN
  l1 as Layer, t1 as Type, l2 as InvalidLayerDependency, collect(t2) as InvalidTypeDependencies
----

[[arch:detectIllegalDomainDependencies]]
[source,cypher,role=constraint,requiresConcepts="arch:markDomains"]
.Find all not allowed dependencies between the domains of the hexagonal architecture
----
MATCH
    (d1:HexArch:Domain)-[:CONTAINS*]->(t1:Type),
    (d2:HexArch:Domain)-[:CONTAINS*]->(t2:Type),
    (t1)-[:DEPENDS_ON]->(t2)
WHERE
    d1 <> d2
WITH
    d1, d2, (count(*) - 2) AS weight, collect(distinct t2) AS violations
MERGE
    (d1)-[d:DEPENDS_ON]->(d2)
SET
    d.weight = weight
RETURN
    d1 AS Domain, d2 AS DomainDependeny, weight AS DependencyWeight,
    violations AS InvalidTypeDependencies
----


[[arch:detectIllegalAdapterDependencies]]
[source,cypher,role=constraint,requiresConcepts="arch:markAdapters"]
.Find all not allowed dependencies between the adapters of the hexagonal architecture
----
MATCH
    (d1:HexArch:Adapter)-[:CONTAINS*]->(t1:Type),
    (d2:HexArch:Adapter)-[:CONTAINS*]->(t2:Type),
    (t1)-[:DEPENDS_ON]->(t2)
WHERE
    d1 <> d2
WITH
    d1, d2, (count(*) - 2) AS weight, collect(distinct t2) AS violations
MERGE
    (d1)-[d:DEPENDS_ON]->(d2)
SET
    d.weight = weight
RETURN
    d1 AS Adapter, d2 AS AdapterDependeny, weight AS DependencyWeight,
    violations AS InvalidTypeDependencies
----


